[00:00:14.757] Server  LOG      ✓ Ready in 12.2s
[00:00:19.740] Server  LOG      ○ Compiling / ...
[00:00:34.607] Browser INFO    %cDownload the React DevTools for a better development experience: https://react.dev/link/react-devtools font-weight:bold
[00:00:44.280] Server  ERROR    ⨯ "The requested resource isn't a valid image for" "/product/home_dark.png" "received" null
[00:01:05.789] Server  ERROR    ⨯ "The requested resource isn't a valid image for" "/product/home_dark.png" "received" null
[00:03:56.341] Server  LOG      ✓ Compiled in 430ms
[00:04:09.570] Server  LOG      ✓ Compiled in 173ms
[00:04:12.405] Server  LOG      ✓ Compiled in 267ms
[00:04:12.558] Server  ERROR    ⨯ "The requested resource isn't a valid image for" "/product/document-intelligence.jpg" "received" null
[00:04:15.633] Server  LOG      ✓ Compiled in 194ms
[00:04:15.638] Server  ERROR    ⨯ "The requested resource isn't a valid image for" "/product/file-repository.jpg" "received" null
[00:04:18.870] Server  LOG      ✓ Compiled in 174ms
[00:04:18.876] Server  ERROR    ⨯ "The requested resource isn't a valid image for" "/product/projects.jpg" "received" null
[00:04:22.034] Server  LOG      ✓ Compiled in 186ms
[00:04:22.092] Server  ERROR    ⨯ "The requested resource isn't a valid image for" "/product/chat.jpg" "received" null
[00:05:18.810] Server  LOG      ✓ Compiled in 492ms
[00:05:29.954] Server  LOG      ✓ Compiled in 143ms
[00:05:29.960] Server  ERROR    ⨯ "The requested resource isn't a valid image for" "/product/chat_white.jpg" "received" null
[00:05:36.309] Browser INFO    %cDownload the React DevTools for a better development experience: https://react.dev/link/react-devtools font-weight:bold
[00:05:36.377] Server  ERROR    ⨯ "The requested resource isn't a valid image for" "/product/document-intelligence.jpg" "received" null
[00:05:36.380] Server  ERROR    ⨯ "The requested resource isn't a valid image for" "/product/chat_white.jpg" "received" null
[00:05:36.384] Server  ERROR    ⨯ "The requested resource isn't a valid image for" "/product/file-repository.jpg" "received" null
[00:05:36.403] Server  ERROR    ⨯ "The requested resource isn't a valid image for" "/product/projects.jpg" "received" null
[00:05:37.636] Server  ERROR    ⨯ "The requested resource isn't a valid image for" "/product/document-intelligence-dark.jpg" "received" null
[00:05:37.637] Server  ERROR    ⨯ "The requested resource isn't a valid image for" "/product/projects-dark.jpg" "received" null
[00:05:37.639] Server  ERROR    ⨯ "The requested resource isn't a valid image for" "/product/file-repository-dark.jpg" "received" null
[00:05:37.652] Server  ERROR    ⨯ "The requested resource isn't a valid image for" "/product/chat_black.jpg" "received" null
[00:05:38.312] Server  ERROR    ⨯ "The requested resource isn't a valid image for" "/product/document-intelligence.jpg" "received" null
[00:05:38.313] Server  ERROR    ⨯ "The requested resource isn't a valid image for" "/product/projects.jpg" "received" null
[00:05:38.329] Server  ERROR    ⨯ "The requested resource isn't a valid image for" "/product/file-repository.jpg" "received" null
[00:05:38.330] Server  ERROR    ⨯ "The requested resource isn't a valid image for" "/product/chat_white.jpg" "received" null
[00:05:49.164] Server  LOG      ✓ Compiled in 239ms
[00:05:51.896] Server  ERROR    ⨯ "The requested resource isn't a valid image for" "/product/document-intelligence-dark.jpg" "received" null
[00:05:51.897] Server  ERROR    ⨯ "The requested resource isn't a valid image for" "/product/projects-dark.jpg" "received" null
[00:05:51.909] Server  ERROR    ⨯ "The requested resource isn't a valid image for" "/product/file-repository-dark.jpg" "received" null
[00:05:52.944] Server  ERROR    ⨯ "The requested resource isn't a valid image for" "/product/document-intelligence.jpg" "received" null
[00:05:52.960] Server  ERROR    ⨯ "The requested resource isn't a valid image for" "/product/projects.jpg" "received" null
[00:05:52.961] Server  ERROR    ⨯ "The requested resource isn't a valid image for" "/product/file-repository.jpg" "received" null
[00:05:53.418] Server  ERROR    ⨯ "The requested resource isn't a valid image for" "/product/document-intelligence-dark.jpg" "received" null
[00:05:53.445] Server  ERROR    ⨯ "The requested resource isn't a valid image for" "/product/projects-dark.jpg" "received" null
[00:05:53.447] Server  ERROR    ⨯ "The requested resource isn't a valid image for" "/product/file-repository-dark.jpg" "received" null
[00:05:54.316] Server  ERROR    ⨯ "The requested resource isn't a valid image for" "/product/document-intelligence.jpg" "received" null
[00:05:54.327] Server  ERROR    ⨯ "The requested resource isn't a valid image for" "/product/projects.jpg" "received" null
[00:05:54.328] Server  ERROR    ⨯ "The requested resource isn't a valid image for" "/product/file-repository.jpg" "received" null
[00:05:55.205] Server  ERROR    ⨯ "The requested resource isn't a valid image for" "/product/document-intelligence-dark.jpg" "received" null
[00:05:55.216] Server  ERROR    ⨯ "The requested resource isn't a valid image for" "/product/projects-dark.jpg" "received" null
[00:05:55.216] Server  ERROR    ⨯ "The requested resource isn't a valid image for" "/product/file-repository-dark.jpg" "received" null
[00:05:56.955] Server  ERROR    ⨯ "The requested resource isn't a valid image for" "/product/document-intelligence.jpg" "received" null
[00:05:56.956] Server  ERROR    ⨯ "The requested resource isn't a valid image for" "/product/projects.jpg" "received" null
[00:05:56.963] Server  ERROR    ⨯ "The requested resource isn't a valid image for" "/product/file-repository.jpg" "received" null
[00:05:58.037] Server  ERROR    ⨯ "The requested resource isn't a valid image for" "/product/document-intelligence-dark.jpg" "received" null
[00:05:58.046] Server  ERROR    ⨯ "The requested resource isn't a valid image for" "/product/projects-dark.jpg" "received" null
[00:05:58.047] Server  ERROR    ⨯ "The requested resource isn't a valid image for" "/product/file-repository-dark.jpg" "received" null
[00:06:09.025] Server  LOG      ✓ Compiled in 150ms
[00:06:18.844] Server  LOG      ✓ Compiled in 166ms
[00:06:28.181] Server  LOG      ✓ Compiled in 176ms
[00:06:45.495] Server  LOG      ✓ Compiled in 167ms
[00:06:57.671] Server  LOG      ✓ Compiled in 156ms
[00:07:02.114] Server  ERROR    ⨯ "The requested resource isn't a valid image for" "/product/document-intelligence.jpg" "received" null
[00:07:02.124] Server  ERROR    ⨯ "The requested resource isn't a valid image for" "/product/projects.jpg" "received" null
[00:07:02.125] Server  ERROR    ⨯ "The requested resource isn't a valid image for" "/product/file-repository.jpg" "received" null
[00:07:06.508] Server  ERROR    ⨯ "The requested resource isn't a valid image for" "/product/document-intelligence-dark.jpg" "received" null
[00:07:06.519] Server  ERROR    ⨯ "The requested resource isn't a valid image for" "/product/projects-dark.jpg" "received" null
[00:07:06.520] Server  ERROR    ⨯ "The requested resource isn't a valid image for" "/product/file-repository-dark.jpg" "received" null
[00:07:18.811] Server  ERROR    ⨯ "The requested resource isn't a valid image for" "/product/document_black.png" "received" null
[00:07:18.814] Server  LOG      ✓ Compiled in 157ms
[00:07:51.035] Browser INFO    %cDownload the React DevTools for a better development experience: https://react.dev/link/react-devtools font-weight:bold
[00:07:51.049] Server  ERROR    ⨯ "The requested resource isn't a valid image for" "/product/projects.jpg" "received" null
[00:07:51.263] Server  ERROR    ⨯ "The requested resource isn't a valid image for" "/product/file-repository.jpg" "received" null
[00:07:51.446] Server  ERROR    ⨯ "The requested resource isn't a valid image for" "/product/projects-dark.jpg" "received" null
[00:07:51.457] Server  ERROR    ⨯ "The requested resource isn't a valid image for" "/product/file-repository-dark.jpg" "received" null
[00:07:53.693] Server  ERROR    ⨯ "The requested resource isn't a valid image for" "/product/projects.jpg" "received" null
[00:07:53.698] Server  ERROR    ⨯ "The requested resource isn't a valid image for" "/product/file-repository.jpg" "received" null
[00:07:54.939] Server  ERROR    ⨯ "The requested resource isn't a valid image for" "/product/projects-dark.jpg" "received" null
[00:07:54.949] Server  ERROR    ⨯ "The requested resource isn't a valid image for" "/product/file-repository-dark.jpg" "received" null
[00:07:55.798] Server  ERROR    ⨯ "The requested resource isn't a valid image for" "/product/projects.jpg" "received" null
[00:07:55.805] Server  ERROR    ⨯ "The requested resource isn't a valid image for" "/product/file-repository.jpg" "received" null
[00:08:08.177] Server  LOG      ✓ Compiled in 180ms
[00:08:20.489] Server  LOG      ✓ Compiled in 170ms
[00:09:34.889] Browser INFO    %cDownload the React DevTools for a better development experience: https://react.dev/link/react-devtools font-weight:bold
[00:09:35.736] Browser WARN    Image with src "/product/home_black.png" was detected as the Largest Contentful Paint (LCP). Please add the `loading="eager"` property if this image is above the fold.
Read more: https://nextjs.org/docs/app/api-reference/components/image#loading
[00:16:41.617] Browser INFO    %cDownload the React DevTools for a better development experience: https://react.dev/link/react-devtools font-weight:bold
[00:17:15.421] Browser INFO    %cDownload the React DevTools for a better development experience: https://react.dev/link/react-devtools font-weight:bold
[00:20:17.415] Browser INFO    %cDownload the React DevTools for a better development experience: https://react.dev/link/react-devtools font-weight:bold
[00:21:08.513] Server  LOG      ✓ Compiled in 188ms
[00:23:07.677] Server  LOG      ✓ Compiled in 622ms
[00:23:14.899] Browser INFO    %cDownload the React DevTools for a better development experience: https://react.dev/link/react-devtools font-weight:bold
[00:23:16.028] Server  LOG      ✓ Compiled in 647ms
[00:23:25.978] Server  LOG      ✓ Compiled in 381ms
[00:23:51.167] Browser INFO    %cDownload the React DevTools for a better development experience: https://react.dev/link/react-devtools font-weight:bold
[00:23:53.307] Server  LOG      ✓ Compiled in 274ms
[00:24:09.910] Server  LOG      ✓ Compiled in 294ms
[00:24:15.256] Server  LOG      ✓ Compiled in 244ms
[00:24:15.355] Browser ERROR   The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s useLayoutEffect [40, 0.03, 10, 20%, 5%, 0.85, 0.5, 0, 0, true, false, , ()=>{
            if (useWindowScroll) {
                const lenis = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lenis$40$1$2e$3$2e$15_react$40$19$2e$2$2e$0$2f$node_modules$2f$lenis$2f$dist$2f$lenis$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
                    duration: 1.2,
                    easing: {
                        "ScrollStack.useCallback[setupLenis]": (t)=>Math.min(1, 1.001 - Math.pow(2, -10 * t))
                    }["ScrollStack.useCallback[setupLenis]"],
                    smoothWheel: true,
                    touchMultiplier: 2,
                    infinite: false,
                    wheelMultiplier: 1,
                    lerp: 0.1,
                    syncTouch: true,
                    syncTouchLerp: 0.075
                });
                lenis.on('scroll', handleScroll);
                const raf = {
                    "ScrollStack.useCallback[setupLenis].raf": (time)=>{
                        lenis.raf(time);
                        animationFrameRef.current = requestAnimationFrame(raf);
                    }
                }["ScrollStack.useCallback[setupLenis].raf"];
                animationFrameRef.current = requestAnimationFrame(raf);
                lenisRef.current = lenis;
                return lenis;
            } else {
                const scroller = scrollerRef.current;
                if (!scroller) return;
                const lenis = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lenis$40$1$2e$3$2e$15_react$40$19$2e$2$2e$0$2f$node_modules$2f$lenis$2f$dist$2f$lenis$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
                    wrapper: scroller,
                    content: scroller.querySelector('.scroll-stack-inner'),
                    duration: 1.2,
                    easing: {
                        "ScrollStack.useCallback[setupLenis]": (t)=>Math.min(1, 1.001 - Math.pow(2, -10 * t))
                    }["ScrollStack.useCallback[setupLenis]"],
                    smoothWheel: true,
                    touchMultiplier: 2,
                    infinite: false,
                    gestureOrientation: 'vertical',
                    wheelMultiplier: 1,
                    lerp: 0.1,
                    syncTouch: true,
                    syncTouchLerp: 0.075
                });
                lenis.on('scroll', handleScroll);
                const raf = {
                    "ScrollStack.useCallback[setupLenis].raf": (time)=>{
                        lenis.raf(time);
                        animationFrameRef.current = requestAnimationFrame(raf);
                    }
                }["ScrollStack.useCallback[setupLenis].raf"];
                animationFrameRef.current = requestAnimationFrame(raf);
                lenisRef.current = lenis;
                return lenis;
            }
        }, ()=>{
            if (!cardsRef.current.length || isUpdatingRef.current) return;
            isUpdatingRef.current = true;
            const { scrollTop, containerHeight } = getScrollData();
            const stackPositionPx = parsePercentage(stackPosition, containerHeight);
            const scaleEndPositionPx = parsePercentage(scaleEndPosition, containerHeight);
            const endElement = useWindowScroll ? document.querySelector('.scroll-stack-end') : scrollerRef.current?.querySelector('.scroll-stack-end');
            const endElementTop = endElement ? getElementOffset(endElement, false) : 0;
            // Batch DOM reads
            const cardTops = cardsRef.current.map({
                "ScrollStack.useCallback[updateCardTransforms].cardTops": (card)=>card ? getElementOffset(card, true) : 0
            }["ScrollStack.useCallback[updateCardTransforms].cardTops"]);
            cardsRef.current.forEach({
                "ScrollStack.useCallback[updateCardTransforms]": (card, i)=>{
                    if (!card) return;
                    const cardTop = cardTops[i];
                    const triggerStart = cardTop - stackPositionPx - itemStackDistance * i;
                    const triggerEnd = cardTop - scaleEndPositionPx;
                    const pinStart = cardTop - stackPositionPx - itemStackDistance * i;
                    const pinEnd = endElementTop - containerHeight / 2;
                    const scaleProgress = calculateProgress(scrollTop, triggerStart, triggerEnd);
                    const targetScale = baseScale + i * itemScale;
                    const scale = 1 - scaleProgress * (1 - targetScale);
                    const rotation = rotationAmount ? i * rotationAmount * scaleProgress : 0;
                    let blur = 0;
                    if (blurAmount) {
                        let topCardIndex = 0;
                        for(let j = 0; j < cardsRef.current.length; j++){
                            const jCardTop = cardTops[j];
                            const jTriggerStart = jCardTop - stackPositionPx - itemStackDistance * j;
                            if (scrollTop >= jTriggerStart) {
                                topCardIndex = j;
                            }
                        }
                        if (i < topCardIndex) {
                            const depthInStack = topCardIndex - i;
                            blur = Math.max(0, depthInStack * blurAmount);
                        }
                    }
                    let translateY = 0;
                    const isPinned = scrollTop >= pinStart && scrollTop <= pinEnd;
                    if (isPinned) {
                        translateY = scrollTop - cardTop + stackPositionPx + itemStackDistance * i;
                    } else if (scrollTop > pinEnd) {
                        translateY = pinEnd - cardTop + stackPositionPx + itemStackDistance * i;
                    }
                    const newTransform = {
                        translateY: Math.round(translateY * 100) / 100,
                        scale: Math.round(scale * 1000) / 1000,
                        rotation: Math.round(rotation * 100) / 100,
                        blur: Math.round(blur * 100) / 100
                    };
                    const lastTransform = lastTransformsRef.current.get(i);
                    const hasChanged = !lastTransform || Math.abs(lastTransform.translateY - newTransform.translateY) > 0.1 || Math.abs(lastTransform.scale - newTransform.scale) > 0.001 || Math.abs(lastTransform.rotation - newTransform.rotation) > 0.1 || Math.abs(lastTransform.blur - newTransform.blur) > 0.1;
                    if (hasChanged) {
                        const transform = `translate3d(0, ${newTransform.translateY}px, 0) scale(${newTransform.scale}) rotate(${newTransform.rotation}deg)`;
                        const filter = newTransform.blur > 0 ? `blur(${newTransform.blur}px)` : '';
                        card.style.transform = transform;
                        card.style.filter = filter;
                        lastTransformsRef.current.set(i, newTransform);
                    }
                    if (i === cardsRef.current.length - 1) {
                        const isInView = scrollTop >= pinStart && scrollTop <= pinEnd;
                        if (isInView && !stackCompletedRef.current) {
                            stackCompletedRef.current = true;
                            onStackComplete?.();
                        } else if (!isInView && stackCompletedRef.current) {
                            stackCompletedRef.current = false;
                        }
                    }
                }
            }["ScrollStack.useCallback[updateCardTransforms]"]);
            isUpdatingRef.current = false;
        }, ()=>{
            if (rafScheduledRef.current) return;
            rafScheduledRef.current = true;
            requestAnimationFrame({
                "ScrollStack.useCallback[handleScroll]": ()=>{
                    rafScheduledRef.current = false;
                    updateCardTransforms();
                }
            }["ScrollStack.useCallback[handleScroll]"]);
        }, ()=>{
            if (animationFrameRef.current) {
                cancelAnimationFrame(animationFrameRef.current);
                animationFrameRef.current = null;
            }
            if (lenisRef.current) {
                lenisRef.current.destroy();
                lenisRef.current = null;
            }
            stackCompletedRef.current = false;
            cardsRef.current = [];
            lastTransformsRef.current.clear();
            isUpdatingRef.current = false;
        }] [40, 0.03, 10, 20%, 5%, 0.85, 0.5, 0, 0, true, false, , ()=>{
            if (useWindowScroll) {
                const lenis = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lenis$40$1$2e$3$2e$15_react$40$19$2e$2$2e$0$2f$node_modules$2f$lenis$2f$dist$2f$lenis$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
                    duration: 1.2,
                    easing: {
                        "ScrollStack.useCallback[setupLenis]": (t)=>Math.min(1, 1.001 - Math.pow(2, -10 * t))
                    }["ScrollStack.useCallback[setupLenis]"],
                    smoothWheel: true,
                    touchMultiplier: 2,
                    infinite: false,
                    wheelMultiplier: 1,
                    lerp: 0.1,
                    syncTouch: true,
                    syncTouchLerp: 0.075
                });
                lenis.on('scroll', handleScroll);
                const raf = {
                    "ScrollStack.useCallback[setupLenis].raf": (time)=>{
                        lenis.raf(time);
                        animationFrameRef.current = requestAnimationFrame(raf);
                    }
                }["ScrollStack.useCallback[setupLenis].raf"];
                animationFrameRef.current = requestAnimationFrame(raf);
                lenisRef.current = lenis;
                return lenis;
            } else {
                const scroller = scrollerRef.current;
                if (!scroller) return;
                const lenis = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lenis$40$1$2e$3$2e$15_react$40$19$2e$2$2e$0$2f$node_modules$2f$lenis$2f$dist$2f$lenis$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
                    wrapper: scroller,
                    content: scroller.querySelector('.scroll-stack-inner'),
                    duration: 1.2,
                    easing: {
                        "ScrollStack.useCallback[setupLenis]": (t)=>Math.min(1, 1.001 - Math.pow(2, -10 * t))
                    }["ScrollStack.useCallback[setupLenis]"],
                    smoothWheel: true,
                    touchMultiplier: 2,
                    infinite: false,
                    gestureOrientation: 'vertical',
                    wheelMultiplier: 1,
                    lerp: 0.1,
                    syncTouch: true,
                    syncTouchLerp: 0.075
                });
                lenis.on('scroll', handleScroll);
                const raf = {
                    "ScrollStack.useCallback[setupLenis].raf": (time)=>{
                        lenis.raf(time);
                        animationFrameRef.current = requestAnimationFrame(raf);
                    }
                }["ScrollStack.useCallback[setupLenis].raf"];
                animationFrameRef.current = requestAnimationFrame(raf);
                lenisRef.current = lenis;
                return lenis;
            }
        }, ()=>{
            if (!cardsRef.current.length || isUpdatingRef.current) return;
            isUpdatingRef.current = true;
            const { scrollTop, containerHeight } = getScrollData();
            const stackPositionPx = parsePercentage(stackPosition, containerHeight);
            const scaleEndPositionPx = parsePercentage(scaleEndPosition, containerHeight);
            const endElement = useWindowScroll ? document.querySelector('.scroll-stack-end') : scrollerRef.current?.querySelector('.scroll-stack-end');
            const endElementTop = endElement ? getElementOffset(endElement, false) : 0;
            // Batch DOM reads
            const cardTops = cardsRef.current.map({
                "ScrollStack.useCallback[updateCardTransforms].cardTops": (card)=>card ? getElementOffset(card, true) : 0
            }["ScrollStack.useCallback[updateCardTransforms].cardTops"]);
            cardsRef.current.forEach({
                "ScrollStack.useCallback[updateCardTransforms]": (card, i)=>{
                    if (!card) return;
                    const cardTop = cardTops[i];
                    const triggerStart = cardTop - stackPositionPx - itemStackDistance * i;
                    const triggerEnd = cardTop - scaleEndPositionPx;
                    const pinStart = cardTop - stackPositionPx - itemStackDistance * i;
                    const pinEnd = endElementTop - containerHeight / 2;
                    const scaleProgress = calculateProgress(scrollTop, triggerStart, triggerEnd);
                    const targetScale = baseScale + i * itemScale;
                    const scale = 1 - scaleProgress * (1 - targetScale);
                    const rotation = rotationAmount ? i * rotationAmount * scaleProgress : 0;
                    let blur = 0;
                    if (blurAmount) {
                        let topCardIndex = 0;
                        for(let j = 0; j < cardsRef.current.length; j++){
                            const jCardTop = cardTops[j];
                            const jTriggerStart = jCardTop - stackPositionPx - itemStackDistance * j;
                            if (scrollTop >= jTriggerStart) {
                                topCardIndex = j;
                            }
                        }
                        if (i < topCardIndex) {
                            const depthInStack = topCardIndex - i;
                            blur = Math.max(0, depthInStack * blurAmount);
                        }
                    }
                    let translateY = 0;
                    const isPinned = scrollTop >= pinStart && scrollTop <= pinEnd;
                    if (isPinned) {
                        translateY = scrollTop - cardTop + stackPositionPx + itemStackDistance * i;
                    } else if (scrollTop > pinEnd) {
                        translateY = pinEnd - cardTop + stackPositionPx + itemStackDistance * i;
                    }
                    const newTransform = {
                        translateY: Math.round(translateY * 100) / 100,
                        scale: Math.round(scale * 1000) / 1000,
                        rotation: Math.round(rotation * 100) / 100,
                        blur: Math.round(blur * 100) / 100
                    };
                    const lastTransform = lastTransformsRef.current.get(i);
                    const hasChanged = !lastTransform || Math.abs(lastTransform.translateY - newTransform.translateY) > 0.1 || Math.abs(lastTransform.scale - newTransform.scale) > 0.001 || Math.abs(lastTransform.rotation - newTransform.rotation) > 0.1 || Math.abs(lastTransform.blur - newTransform.blur) > 0.1;
                    if (hasChanged) {
                        const transform = `translate3d(0, ${newTransform.translateY}px, 0) scale(${newTransform.scale}) rotate(${newTransform.rotation}deg)`;
                        const filter = newTransform.blur > 0 ? `blur(${newTransform.blur}px)` : '';
                        card.style.transform = transform;
                        card.style.filter = filter;
                        lastTransformsRef.current.set(i, newTransform);
                    }
                    if (i === cardsRef.current.length - 1) {
                        const isInView = scrollTop >= pinStart && scrollTop <= pinEnd;
                        if (isInView && !stackCompletedRef.current) {
                            stackCompletedRef.current = true;
                            onStackComplete?.();
                        } else if (!isInView && stackCompletedRef.current) {
                            stackCompletedRef.current = false;
                        }
                    }
                }
            }["ScrollStack.useCallback[updateCardTransforms]"]);
            isUpdatingRef.current = false;
        }, ()=>{
            if (rafScheduledRef.current) return;
            rafScheduledRef.current = true;
            requestAnimationFrame({
                "ScrollStack.useCallback[handleScroll]": ()=>{
                    rafScheduledRef.current = false;
                    updateCardTransforms();
                }
            }["ScrollStack.useCallback[handleScroll]"]);
        }, ()=>{
            if (animationFrameRef.current) {
                cancelAnimationFrame(animationFrameRef.current);
                animationFrameRef.current = null;
            }
            if (lenisRef.current) {
                lenisRef.current.destroy();
                lenisRef.current = null;
            }
            stackCompletedRef.current = false;
            cardsRef.current = [];
            lastTransformsRef.current.clear();
            isUpdatingRef.current = false;
        }, ()=>{
            cardPositionsRef.current.clear();
            cardsRef.current.forEach({
                "ScrollStack.useCallback[recalculateCardPositions]": (card)=>{
                    if (card) {
                        if (useWindowScroll) {
                            const rect = card.getBoundingClientRect();
                            cardPositionsRef.current.set(card, rect.top + window.scrollY);
                        } else {
                            cardPositionsRef.current.set(card, card.offsetTop);
                        }
                    }
                }
            }["ScrollStack.useCallback[recalculateCardPositions]"]);
        }]
[00:24:16.083] Browser ERROR   The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s useLayoutEffect [40, 0.03, 10, 20%, 5%, 0.85, 0.5, 0, 0, true, false, , ()=>{
            if (useWindowScroll) {
                const lenis = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lenis$40$1$2e$3$2e$15_react$40$19$2e$2$2e$0$2f$node_modules$2f$lenis$2f$dist$2f$lenis$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
                    duration: 1.2,
                    easing: {
                        "ScrollStack.useCallback[setupLenis]": (t)=>Math.min(1, 1.001 - Math.pow(2, -10 * t))
                    }["ScrollStack.useCallback[setupLenis]"],
                    smoothWheel: true,
                    touchMultiplier: 2,
                    infinite: false,
                    wheelMultiplier: 1,
                    lerp: 0.1,
                    syncTouch: true,
                    syncTouchLerp: 0.075
                });
                lenis.on('scroll', handleScroll);
                const raf = {
                    "ScrollStack.useCallback[setupLenis].raf": (time)=>{
                        lenis.raf(time);
                        animationFrameRef.current = requestAnimationFrame(raf);
                    }
                }["ScrollStack.useCallback[setupLenis].raf"];
                animationFrameRef.current = requestAnimationFrame(raf);
                lenisRef.current = lenis;
                return lenis;
            } else {
                const scroller = scrollerRef.current;
                if (!scroller) return;
                const lenis = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lenis$40$1$2e$3$2e$15_react$40$19$2e$2$2e$0$2f$node_modules$2f$lenis$2f$dist$2f$lenis$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
                    wrapper: scroller,
                    content: scroller.querySelector('.scroll-stack-inner'),
                    duration: 1.2,
                    easing: {
                        "ScrollStack.useCallback[setupLenis]": (t)=>Math.min(1, 1.001 - Math.pow(2, -10 * t))
                    }["ScrollStack.useCallback[setupLenis]"],
                    smoothWheel: true,
                    touchMultiplier: 2,
                    infinite: false,
                    gestureOrientation: 'vertical',
                    wheelMultiplier: 1,
                    lerp: 0.1,
                    syncTouch: true,
                    syncTouchLerp: 0.075
                });
                lenis.on('scroll', handleScroll);
                const raf = {
                    "ScrollStack.useCallback[setupLenis].raf": (time)=>{
                        lenis.raf(time);
                        animationFrameRef.current = requestAnimationFrame(raf);
                    }
                }["ScrollStack.useCallback[setupLenis].raf"];
                animationFrameRef.current = requestAnimationFrame(raf);
                lenisRef.current = lenis;
                return lenis;
            }
        }, ()=>{
            if (!cardsRef.current.length || isUpdatingRef.current) return;
            isUpdatingRef.current = true;
            const { scrollTop, containerHeight } = getScrollData();
            const stackPositionPx = parsePercentage(stackPosition, containerHeight);
            const scaleEndPositionPx = parsePercentage(scaleEndPosition, containerHeight);
            const endElement = useWindowScroll ? document.querySelector('.scroll-stack-end') : scrollerRef.current?.querySelector('.scroll-stack-end');
            const endElementTop = endElement ? getElementOffset(endElement, false) : 0;
            // Batch DOM reads
            const cardTops = cardsRef.current.map({
                "ScrollStack.useCallback[updateCardTransforms].cardTops": (card)=>card ? getElementOffset(card, true) : 0
            }["ScrollStack.useCallback[updateCardTransforms].cardTops"]);
            cardsRef.current.forEach({
                "ScrollStack.useCallback[updateCardTransforms]": (card, i)=>{
                    if (!card) return;
                    const cardTop = cardTops[i];
                    const triggerStart = cardTop - stackPositionPx - itemStackDistance * i;
                    const triggerEnd = cardTop - scaleEndPositionPx;
                    const pinStart = cardTop - stackPositionPx - itemStackDistance * i;
                    const pinEnd = endElementTop - containerHeight / 2;
                    const scaleProgress = calculateProgress(scrollTop, triggerStart, triggerEnd);
                    const targetScale = baseScale + i * itemScale;
                    const scale = 1 - scaleProgress * (1 - targetScale);
                    const rotation = rotationAmount ? i * rotationAmount * scaleProgress : 0;
                    let blur = 0;
                    if (blurAmount) {
                        let topCardIndex = 0;
                        for(let j = 0; j < cardsRef.current.length; j++){
                            const jCardTop = cardTops[j];
                            const jTriggerStart = jCardTop - stackPositionPx - itemStackDistance * j;
                            if (scrollTop >= jTriggerStart) {
                                topCardIndex = j;
                            }
                        }
                        if (i < topCardIndex) {
                            const depthInStack = topCardIndex - i;
                            blur = Math.max(0, depthInStack * blurAmount);
                        }
                    }
                    let translateY = 0;
                    const isPinned = scrollTop >= pinStart && scrollTop <= pinEnd;
                    if (isPinned) {
                        translateY = scrollTop - cardTop + stackPositionPx + itemStackDistance * i;
                    } else if (scrollTop > pinEnd) {
                        translateY = pinEnd - cardTop + stackPositionPx + itemStackDistance * i;
                    }
                    const newTransform = {
                        translateY: Math.round(translateY * 100) / 100,
                        scale: Math.round(scale * 1000) / 1000,
                        rotation: Math.round(rotation * 100) / 100,
                        blur: Math.round(blur * 100) / 100
                    };
                    const lastTransform = lastTransformsRef.current.get(i);
                    const hasChanged = !lastTransform || Math.abs(lastTransform.translateY - newTransform.translateY) > 0.1 || Math.abs(lastTransform.scale - newTransform.scale) > 0.001 || Math.abs(lastTransform.rotation - newTransform.rotation) > 0.1 || Math.abs(lastTransform.blur - newTransform.blur) > 0.1;
                    if (hasChanged) {
                        const transform = `translate3d(0, ${newTransform.translateY}px, 0) scale(${newTransform.scale}) rotate(${newTransform.rotation}deg)`;
                        const filter = newTransform.blur > 0 ? `blur(${newTransform.blur}px)` : '';
                        card.style.transform = transform;
                        card.style.filter = filter;
                        lastTransformsRef.current.set(i, newTransform);
                    }
                    if (i === cardsRef.current.length - 1) {
                        const isInView = scrollTop >= pinStart && scrollTop <= pinEnd;
                        if (isInView && !stackCompletedRef.current) {
                            stackCompletedRef.current = true;
                            onStackComplete?.();
                        } else if (!isInView && stackCompletedRef.current) {
                            stackCompletedRef.current = false;
                        }
                    }
                }
            }["ScrollStack.useCallback[updateCardTransforms]"]);
            isUpdatingRef.current = false;
        }, ()=>{
            if (rafScheduledRef.current) return;
            rafScheduledRef.current = true;
            requestAnimationFrame({
                "ScrollStack.useCallback[handleScroll]": ()=>{
                    rafScheduledRef.current = false;
                    updateCardTransforms();
                }
            }["ScrollStack.useCallback[handleScroll]"]);
        }, ()=>{
            if (animationFrameRef.current) {
                cancelAnimationFrame(animationFrameRef.current);
                animationFrameRef.current = null;
            }
            if (lenisRef.current) {
                lenisRef.current.destroy();
                lenisRef.current = null;
            }
            stackCompletedRef.current = false;
            cardsRef.current = [];
            lastTransformsRef.current.clear();
            isUpdatingRef.current = false;
        }] [40, 0.03, 10, 20%, 5%, 0.85, 0.5, 0, 0, true, false, , ()=>{
            if (useWindowScroll) {
                const lenis = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lenis$40$1$2e$3$2e$15_react$40$19$2e$2$2e$0$2f$node_modules$2f$lenis$2f$dist$2f$lenis$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
                    duration: 1.2,
                    easing: {
                        "ScrollStack.useCallback[setupLenis]": (t)=>Math.min(1, 1.001 - Math.pow(2, -10 * t))
                    }["ScrollStack.useCallback[setupLenis]"],
                    smoothWheel: true,
                    touchMultiplier: 2,
                    infinite: false,
                    wheelMultiplier: 1,
                    lerp: 0.1,
                    syncTouch: true,
                    syncTouchLerp: 0.075
                });
                lenis.on('scroll', handleScroll);
                const raf = {
                    "ScrollStack.useCallback[setupLenis].raf": (time)=>{
                        lenis.raf(time);
                        animationFrameRef.current = requestAnimationFrame(raf);
                    }
                }["ScrollStack.useCallback[setupLenis].raf"];
                animationFrameRef.current = requestAnimationFrame(raf);
                lenisRef.current = lenis;
                return lenis;
            } else {
                const scroller = scrollerRef.current;
                if (!scroller) return;
                const lenis = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lenis$40$1$2e$3$2e$15_react$40$19$2e$2$2e$0$2f$node_modules$2f$lenis$2f$dist$2f$lenis$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
                    wrapper: scroller,
                    content: scroller.querySelector('.scroll-stack-inner'),
                    duration: 1.2,
                    easing: {
                        "ScrollStack.useCallback[setupLenis]": (t)=>Math.min(1, 1.001 - Math.pow(2, -10 * t))
                    }["ScrollStack.useCallback[setupLenis]"],
                    smoothWheel: true,
                    touchMultiplier: 2,
                    infinite: false,
                    gestureOrientation: 'vertical',
                    wheelMultiplier: 1,
                    lerp: 0.1,
                    syncTouch: true,
                    syncTouchLerp: 0.075
                });
                lenis.on('scroll', handleScroll);
                const raf = {
                    "ScrollStack.useCallback[setupLenis].raf": (time)=>{
                        lenis.raf(time);
                        animationFrameRef.current = requestAnimationFrame(raf);
                    }
                }["ScrollStack.useCallback[setupLenis].raf"];
                animationFrameRef.current = requestAnimationFrame(raf);
                lenisRef.current = lenis;
                return lenis;
            }
        }, ()=>{
            if (!cardsRef.current.length || isUpdatingRef.current) return;
            isUpdatingRef.current = true;
            const { scrollTop, containerHeight } = getScrollData();
            const stackPositionPx = parsePercentage(stackPosition, containerHeight);
            const scaleEndPositionPx = parsePercentage(scaleEndPosition, containerHeight);
            const endElement = useWindowScroll ? document.querySelector('.scroll-stack-end') : scrollerRef.current?.querySelector('.scroll-stack-end');
            const endElementTop = endElement ? getElementOffset(endElement, false) : 0;
            // Batch DOM reads
            const cardTops = cardsRef.current.map({
                "ScrollStack.useCallback[updateCardTransforms].cardTops": (card)=>card ? getElementOffset(card, true) : 0
            }["ScrollStack.useCallback[updateCardTransforms].cardTops"]);
            cardsRef.current.forEach({
                "ScrollStack.useCallback[updateCardTransforms]": (card, i)=>{
                    if (!card) return;
                    const cardTop = cardTops[i];
                    const triggerStart = cardTop - stackPositionPx - itemStackDistance * i;
                    const triggerEnd = cardTop - scaleEndPositionPx;
                    const pinStart = cardTop - stackPositionPx - itemStackDistance * i;
                    const pinEnd = endElementTop - containerHeight / 2;
                    const scaleProgress = calculateProgress(scrollTop, triggerStart, triggerEnd);
                    const targetScale = baseScale + i * itemScale;
                    const scale = 1 - scaleProgress * (1 - targetScale);
                    const rotation = rotationAmount ? i * rotationAmount * scaleProgress : 0;
                    let blur = 0;
                    if (blurAmount) {
                        let topCardIndex = 0;
                        for(let j = 0; j < cardsRef.current.length; j++){
                            const jCardTop = cardTops[j];
                            const jTriggerStart = jCardTop - stackPositionPx - itemStackDistance * j;
                            if (scrollTop >= jTriggerStart) {
                                topCardIndex = j;
                            }
                        }
                        if (i < topCardIndex) {
                            const depthInStack = topCardIndex - i;
                            blur = Math.max(0, depthInStack * blurAmount);
                        }
                    }
                    let translateY = 0;
                    const isPinned = scrollTop >= pinStart && scrollTop <= pinEnd;
                    if (isPinned) {
                        translateY = scrollTop - cardTop + stackPositionPx + itemStackDistance * i;
                    } else if (scrollTop > pinEnd) {
                        translateY = pinEnd - cardTop + stackPositionPx + itemStackDistance * i;
                    }
                    const newTransform = {
                        translateY: Math.round(translateY * 100) / 100,
                        scale: Math.round(scale * 1000) / 1000,
                        rotation: Math.round(rotation * 100) / 100,
                        blur: Math.round(blur * 100) / 100
                    };
                    const lastTransform = lastTransformsRef.current.get(i);
                    const hasChanged = !lastTransform || Math.abs(lastTransform.translateY - newTransform.translateY) > 0.1 || Math.abs(lastTransform.scale - newTransform.scale) > 0.001 || Math.abs(lastTransform.rotation - newTransform.rotation) > 0.1 || Math.abs(lastTransform.blur - newTransform.blur) > 0.1;
                    if (hasChanged) {
                        const transform = `translate3d(0, ${newTransform.translateY}px, 0) scale(${newTransform.scale}) rotate(${newTransform.rotation}deg)`;
                        const filter = newTransform.blur > 0 ? `blur(${newTransform.blur}px)` : '';
                        card.style.transform = transform;
                        card.style.filter = filter;
                        lastTransformsRef.current.set(i, newTransform);
                    }
                    if (i === cardsRef.current.length - 1) {
                        const isInView = scrollTop >= pinStart && scrollTop <= pinEnd;
                        if (isInView && !stackCompletedRef.current) {
                            stackCompletedRef.current = true;
                            onStackComplete?.();
                        } else if (!isInView && stackCompletedRef.current) {
                            stackCompletedRef.current = false;
                        }
                    }
                }
            }["ScrollStack.useCallback[updateCardTransforms]"]);
            isUpdatingRef.current = false;
        }, ()=>{
            if (rafScheduledRef.current) return;
            rafScheduledRef.current = true;
            requestAnimationFrame({
                "ScrollStack.useCallback[handleScroll]": ()=>{
                    rafScheduledRef.current = false;
                    updateCardTransforms();
                }
            }["ScrollStack.useCallback[handleScroll]"]);
        }, ()=>{
            if (animationFrameRef.current) {
                cancelAnimationFrame(animationFrameRef.current);
                animationFrameRef.current = null;
            }
            if (lenisRef.current) {
                lenisRef.current.destroy();
                lenisRef.current = null;
            }
            stackCompletedRef.current = false;
            cardsRef.current = [];
            lastTransformsRef.current.clear();
            isUpdatingRef.current = false;
        }, ()=>{
            cardPositionsRef.current.clear();
            cardsRef.current.forEach({
                "ScrollStack.useCallback[recalculateCardPositions]": (card)=>{
                    if (card) {
                        if (useWindowScroll) {
                            const rect = card.getBoundingClientRect();
                            cardPositionsRef.current.set(card, rect.top + window.scrollY);
                        } else {
                            cardPositionsRef.current.set(card, card.offsetTop);
                        }
                    }
                }
            }["ScrollStack.useCallback[recalculateCardPositions]"]);
        }]
[00:24:21.343] Server  LOG      ✓ Compiled in 217ms
[00:24:35.752] Browser INFO    %cDownload the React DevTools for a better development experience: https://react.dev/link/react-devtools font-weight:bold
[00:24:37.028] Browser INFO    %cDownload the React DevTools for a better development experience: https://react.dev/link/react-devtools font-weight:bold
[00:24:38.682] Browser INFO    %cDownload the React DevTools for a better development experience: https://react.dev/link/react-devtools font-weight:bold
[00:24:45.570] Browser INFO    %cDownload the React DevTools for a better development experience: https://react.dev/link/react-devtools font-weight:bold
[00:25:29.149] Server  LOG      ✓ Compiled in 161ms
[00:26:04.345] Browser INFO    %cDownload the React DevTools for a better development experience: https://react.dev/link/react-devtools font-weight:bold
[00:36:00.498] Server  ERROR   E:\landing-page\dist\dev\server\chunks\ssr\[root-of-the-server]__cd18c803._.js: Invalid source map. Only conformant source maps can be used to find the original code. Cause: Error: sourceMapURL could not be parsed
[00:36:00.616] Server  ERROR    ⨯ ReferenceError: Image is not defined
[00:36:01.229] Browser ERROR   uncaughtError: ReferenceError: Image is not defined
[00:36:25.049] Server  LOG      ✓ Compiled in 244ms
[00:36:25.335] Server  ERROR   E:\landing-page\dist\dev\server\chunks\ssr\[root-of-the-server]__cd18c803._.js: Invalid source map. Only conformant source maps can be used to find the original code. Cause: Error: sourceMapURL could not be parsed
[00:36:25.337] Server  ERROR    ⨯ ReferenceError: Image is not defined
[00:36:26.405] Browser INFO    %cDownload the React DevTools for a better development experience: https://react.dev/link/react-devtools font-weight:bold
[00:36:26.956] Browser ERROR   uncaughtError: ReferenceError: Image is not defined
[00:36:28.087] Server  LOG      ✓ Compiled in 214ms
[00:36:29.287] Browser INFO    %cDownload the React DevTools for a better development experience: https://react.dev/link/react-devtools font-weight:bold
[00:37:25.453] Browser WARN    Image with src "https://images.unsplash.com/photo-1483478550801-ceba5fe50e8e?auto=format&fit=crop&w=800&q=80" was detected as the Largest Contentful Paint (LCP). Please add the `loading="eager"` property if this image is above the fold.
Read more: https://nextjs.org/docs/app/api-reference/components/image#loading
[00:46:10.952] Server  LOG      ✓ Compiled in 1075ms
[00:46:20.445] Browser INFO    %cDownload the React DevTools for a better development experience: https://react.dev/link/react-devtools font-weight:bold
[00:48:02.443] Server  LOG      ✓ Compiled in 520ms
[00:48:54.803] Server  LOG      ✓ Compiled in 209ms
[00:48:58.952] Browser INFO    %cDownload the React DevTools for a better development experience: https://react.dev/link/react-devtools font-weight:bold
[00:49:57.914] Server  LOG      ✓ Compiled in 339ms
[00:50:35.306] Server  LOG      ✓ Compiled in 232ms
[00:50:38.313] Browser INFO    %cDownload the React DevTools for a better development experience: https://react.dev/link/react-devtools font-weight:bold
[00:50:41.015] Browser INFO    %cDownload the React DevTools for a better development experience: https://react.dev/link/react-devtools font-weight:bold
[01:05:26.515] Server  LOG      ✓ Compiled in 220ms
